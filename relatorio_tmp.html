<!DOCTYPE html>
<html>

<head>
    <title>relatorio.md</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

html,footer,header{
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Custom MD PDF CSS
 */
html,footer,header{
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";

 }
body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///home/ludvig/Documentos/vmem-simulator/R%3A%5C2.Travail%5C1.Enseignement%5CCours%5C_1.Outils%5C2.Developpement%5C1.SCSS%5Cmain.css" type="text/css"><link rel="stylesheet" href="file:///home/ludvig/Documentos/vmem-simulator/D%3A%5Crdaros%5CCours%5C_1.Outils%5C2.Developpement%5C1.SCSS%5Cmain.css" type="text/css">
</head>

<body>
    <h1 id="relat%C3%B3rio-do-trabalho-2---mem%C3%B3ria-virtual-paginada-sob-demanda">Relatório do Trabalho 2 - Memória Virtual Paginada Sob Demanda</h1>
<ul>
<li>Davi Ludvig,</li>
<li>João Paulo Oliveira e</li>
<li>Gibram Goulart.</li>
</ul>
<h2 id="sum%C3%A1rio">Sumário</h2>
<ul>
<li><a href="#relat%C3%B3rio-do-trabalho-2---mem%C3%B3ria-virtual-paginada-sob-demanda">Relatório do Trabalho 2 - Memória Virtual Paginada Sob Demanda</a>
<ul>
<li><a href="#sum%C3%A1rio">Sumário</a></li>
<li><a href="#introdu%C3%A7%C3%A3o">Introdução</a>
<ul>
<li><a href="#1-objetivo">1. Objetivo</a></li>
<li><a href="#2-ambiente-experimental">2. Ambiente Experimental</a></li>
<li><a href="#3-arquitetura">3 Arquitetura</a>
<ul>
<li><a href="#31-estrutura-b%C3%A1sica">3.1 Estrutura Básica</a></li>
<li><a href="#32-como-executar-o-sistema">3.2 Como executar o sistema</a></li>
<li><a href="#33-funcionamento-do-tratador-de-page-faults">3.3 Funcionamento do Tratador de Page Faults:</a></li>
<li><a href="#34-diagramas">3.4 Diagramas</a>
<ul>
<li><a href="#341-diagrama-de-classes">3.4.1 Diagrama de classes</a></li>
<li><a href="#342-fluxo">3.4.2 Fluxo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-algoritmos-de-substitui%C3%A7%C3%A3o-de-p%C3%A1gina">4. Algoritmos de Substituição de Página</a>
<ul>
<li><a href="#41-random">4.1. RANDOM</a></li>
<li><a href="#42-fifo-first-in-first-out">4.2. FIFO (First-In, First-Out)</a></li>
<li><a href="#43-custom">4.3 CUSTOM</a></li>
<li><a href="#431-compara%C3%A7%C3%B5es">4.3.1 Comparações</a>
<ul>
<li><a href="#rand">Rand</a></li>
<li><a href="#fifo">FIFO</a></li>
<li><a href="#gr%C3%A1fico-para-entendimento">Gráfico para entendimento</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-resultados-e-an%C3%A1lises">5. Resultados e Análises</a>
<ul>
<li><a href="#51-resultados-dos-testes">5.1 Resultados dos testes</a>
<ul>
<li><a href="#511-alpha">5.1.1 Alpha</a></li>
<li><a href="#512-beta">5.1.2 Beta</a></li>
<li><a href="#513-gamma">5.1.3 Gamma</a></li>
<li><a href="#514-delta">5.1.4 Delta</a></li>
</ul>
</li>
<li><a href="#52-an%C3%A1lise-dos-resultados">5.2 Análise dos resultados</a>
<ul>
<li><a href="#521-semelhan%C3%A7as-entre-fifo-e-custom">5.2.1 Semelhanças entre <code>fifo</code> e <code>custom</code></a></li>
<li><a href="#522-tend%C3%AAncia-geral-decrescente">5.2.2 Tendência Geral Decrescente</a></li>
<li><a href="#523-comportamento-constante-do-gamma-com-fifo-e-custom">5.2.3 Comportamento constante do <code>gamma</code> com <code>fifo</code> e <code>custom</code></a></li>
<li><a href="#524-comportamento-linear-de-delta">5.2.4 Comportamento linear de <code>delta</code></a></li>
<li><a href="#525-tempo-de-execu%C3%A7%C3%A3o">5.2.5 Tempo de execução</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#ap%C3%AAndice">Apêndice</a>
<ul>
<li><a href="#vazamento-de-mem%C3%B3ria">Vazamento de memória</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="introdu%C3%A7%C3%A3o">Introdução</h2>
<p>Este documento reúne um apanhado de informações acerca da solução dos discentes autores para resolver o enunciado do trabalho 2 da disciplina INE5412.</p>
<h3 id="1-objetivo">1. Objetivo</h3>
<p>O objetivo deste trabalho é implementar um sistema de memória virtual paginada sob demanda em espaço de usuário, compreendendo a mecânica do tratamento de faltas de página e avaliando o desempenho de diferentes algoritmos de substituição de páginas (FIFO, RANDOM e um algoritmo personalizado). A implementação foi baseada no projeto do Prof. Douglas Thain (Universidade de Notre Dame), adaptado para o ambiente proposto em aula e disponibilizado pelo professor Giovani Gracioli.</p>
<h3 id="2-ambiente-experimental">2. Ambiente Experimental</h3>
<ul>
<li>
<p><strong>Máquina utilizada</strong>:</p>
<ul>
<li>Sistema Operacional: Ubuntu 24.04 LTS</li>
<li>Compilador: g++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0</li>
<li>Make: GNU Make 4.3 compilado para x86_64-pc-linux-gnu</li>
</ul>
</li>
<li>
<p><strong>Execução dos testes</strong>:<br>
Para cada programa ( <code>alpha</code> , <code>beta</code> , <code>gamma</code> , <code>delta</code> ), os seguintes comandos podem ser executados com variações:</p>
</li>
</ul>
<pre class="hljs"><code><div>  ./virtmem 10 10 rand alpha
  ./virtmem 10 10 fifo beta
  ./virtmem 10 10 custom gamma
  ...
</div></code></pre>
<h3 id="3-arquitetura">3 Arquitetura</h3>
<h4 id="31-estrutura-b%C3%A1sica">3.1 Estrutura Básica</h4>
<p>O projeto foi dividido nas seguintes classes:</p>
<ul>
<li><code>Page_Table</code>: Interface com a tabela de páginas. Gerencia o mapeamento entre páginas virtuais e frames físicos e captura falhas de página usando um tratador de sinais (<code>SIGSEGV</code>).</li>
<li><code>Disk</code>: Simulação de um disco secundário, fornecendo operações de leitura e escrita em blocos.</li>
<li><code>Page_Replacement</code>: Gerencia o estado dos frames físicos (livres/ocupados) e implementa a lógica para os algoritmos de substituição de páginas quando ocorrem falhas de página.</li>
<li><code>Program</code>: Classe responsável por gerenciar os programas utilizados nas execuções (<code>alpha</code>,  <code>beta</code>,  <code>gamma</code> e <code>delta</code>). Ela coordena o fluxo das instruções, realiza acessos à memória virtual e simula os diferentes padrões de uso de memória definidos para os testes.</li>
</ul>
<p>A classe <code>Page_Replacement</code> utiliza estruturas de dados auxiliares para implementar os algoritmos. O <code>std::vector&lt;int&gt; frame_table</code> monitora qual página ocupa cada frame, atendendo ao requisito de gerenciar os frames livres. Para o algoritmo FIFO, a <code>std::queue&lt;int&gt; fifo_queue</code> mantém a ordem de entrada das páginas. Já o algoritmo <code>custom</code> (LRU) utiliza p <code>std::vector&lt;int&gt; tempo_acesso</code> para registrar o tempo do último acesso a cada frame.</p>
<h4 id="32-como-executar-o-sistema">3.2 Como executar o sistema</h4>
<p>Foi construído um arquivo <code>Makefile</code> para facilitar a compilação e execução do sistema. Para compilar o sistema, basta executar o comando na raiz do projeto (onde está localizado o arquivo <code>Makefile</code> ):</p>
<pre class="hljs"><code><div>make
</div></code></pre>
<p>Depois disso, o executável <code>virtmem</code> estará disponível na raiz do projeto. Para executar o sistema, utilize o seguinte comando:</p>
<pre class="hljs"><code><div>./virtmem &lt;número de frames&gt; &lt;número de páginas&gt; &lt;algoritmo de substituição&gt; &lt;programa&gt;
</div></code></pre>
<blockquote>
<p>Todos os objetos <code>.o</code> estão localizados na pasta <code>build</code> , e o executável <code>virtmem</code> está localizado na raiz do projeto.</p>
</blockquote>
<h4 id="33-funcionamento-do-tratador-de-page-faults">3.3 Funcionamento do Tratador de Page Faults:</h4>
<ol>
<li>Uma falta de página (<em>segmentation fault</em>) é detectada pelo sistema operacional, que aciona o tratador de sinais (<code>internal_fault_handler</code>) configurado pela classe <code>Page_Table</code>.</li>
<li>O tratador delega a responsabilidade para a instância da classe <code>Page_Replacement</code>, que incrementa as estatísticas de falhas de página.</li>
<li>Verifica-se se há um frame de memória física livre:
<ul>
<li>Se houver, a página correspondente é lida do disco para o frame livre.</li>
<li>Se não houver, o algoritmo de substituição de página selecionado é acionado para escolher uma página &quot;vítima&quot; a ser removida da memória.
<ul>
<li>Se a página vítima foi modificada (sinalizada com permissão de escrita), ela é escrita de volta no disco para salvar as alterações.</li>
<li>O frame é liberado, e a entrada da página vítima na tabela de páginas é invalidada.</li>
</ul>
</li>
</ul>
</li>
<li>A nova página requisitada é carregada do disco para o frame recém-liberado.</li>
<li>A entrada na tabela de páginas é atualizada para mapear a página ao seu novo frame, com permissão inicial de apenas leitura (<code>PROT_READ</code>).</li>
<li>Se o algoritmo for FIFO, a página é adicionada ao final da fila. Se for LRU (custom), o seu tempo de acesso é registrado.</li>
<li>Se a falta de página ocorreu por uma tentativa de escrita em uma página que já está na memória (com permissão de apenas leitura), o bit de escrita (<code>PROT_WRITE</code>) é ativado, sem a necessidade de acessar o disco.</li>
</ol>
<blockquote>
<p>Estatísticas de execução (page faults, disk reads/writes) são coletadas automaticamente para análise de desempenho.</p>
</blockquote>
<h4 id="34-diagramas">3.4 Diagramas</h4>
<h5 id="341-diagrama-de-classes">3.4.1 Diagrama de classes</h5>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/uml.png" alt="Diagrama de classes"></p>
<h5 id="342-fluxo">3.4.2 Fluxo</h5>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/fluxo.png" alt="Diagrama Fluxo"></p>
<h3 id="4-algoritmos-de-substitui%C3%A7%C3%A3o-de-p%C3%A1gina">4. Algoritmos de Substituição de Página</h3>
<h4 id="41-random">4.1. RANDOM</h4>
<p>Seleciona aleatoriamente um frame para substituição. A implementação utiliza <code>std::rand() % frame_table.size()</code> para escolher o frame a ser desocupado, tornando o processo não determinístico em relação ao histórico de acessos.</p>
<h4 id="42-fifo-first-in-first-out">4.2. FIFO (First-In, First-Out)</h4>
<p>Mantém uma fila ( <code>std::queue</code> ) das páginas carregadas na memória. Quando uma substituição é necessária, a página que está na frente da fila (a que foi carregada há mais tempo) é removida.</p>
<h4 id="43-custom">4.3 CUSTOM</h4>
<ul>
<li>Como algoritmo personalizado <code>custom</code> construído pelo grupo, foi decidido implementar uma versão do algoritmo de substituição de páginas <strong>LRU (Least Recently Used)</strong>.</li>
<li>Na inicialização da classe <code>Page_Replacement</code>, são definidos dois atributos:</li>
</ul>
<ol>
<li>O vetor de inteiros <code>tempo_acesso</code>, que armazena o &quot;tempo&quot; do último acesso de cada frame.</li>
<li>O inteiro <code>tempo_atual</code>, que é incrementado a cada vez que uma falha de página é tratada, servindo como um relógio lógico.</li>
</ol>
<ul>
<li>Dentro do método <code>Page_Replacement::select_frame_to_be_removed</code>, ao checar que o algoritmo é <code>custom</code>, os seguintes passos são aplicados:</li>
</ul>
<ol>
<li>Define o tempo mínimo como o maior inteiro possível.</li>
<li>Define o frame a ser removido como -1. (Nenhum frame)</li>
<li>Para cada frame, faça
<ol>
<li>Se o tempo de acesso do frame for menor que o tempo mínimo, defina que o índice frame a ser removido é o atual.</li>
</ol>
</li>
<li>Retorne o índice do frame a ser removido.</li>
</ol>
<ul>
<li>O tempo de acesso de um frame é atualizado sempre que a página contida nele é referenciada, seja por uma falta de página que carrega dados ou por uma falta de permissão que concede direito de escrita.</li>
</ul>
<h4 id="431-compara%C3%A7%C3%B5es">4.3.1 Comparações</h4>
<h5 id="rand">Rand</h5>
<ul>
<li>O algoritmo <code>rand</code> seleciona um frame aleatoriamente para remoção, o que pode levar a uma alta taxa de faltas de página, especialmente em cenários onde as páginas acessadas recentemente são necessárias novamente.</li>
<li>Nesse cenário, existirão diversas possibilidades do <code>custom</code> se sair melhor que o <code>rand</code>, pois o <code>custom</code> prioriza a remoção de páginas que não foram acessadas recentemente, enquanto o <code>rand</code> não considera o histórico de acesso.</li>
</ul>
<h5 id="fifo">FIFO</h5>
<ul>
<li>O algoritmo <code>fifo</code> remove a página que foi carregada há mais tempo, o que pode levar a uma taxa de faltas de página alta se as páginas acessadas recentemente forem removidas (<strong>Anomalia de Belady</strong>).</li>
<li>O <code>custom</code> (<strong>LRU</strong>) pode se sair melhor que o <code>fifo</code> em cenários onde as páginas acessadas recentemente são necessárias novamente, pois o <code>custom</code> prioriza a remoção de páginas que não foram acessadas recentemente.</li>
<li>Além disso, em cenários onde há uma alta taxa de acesso a páginas, o <code>custom</code> pode se sair melhor que o <code>fifo</code>, pois o <code>fifo</code> não considera o histórico de acesso das páginas, enquanto o <code>custom</code> prioriza a remoção de páginas que não foram acessadas recentemente. Isso pode ser perceptível também em cenários com bastante leitura.</li>
</ul>
<h5 id="gr%C3%A1fico-para-entendimento">Gráfico para entendimento</h5>
<ul>
<li>Foi constrúido o seguinte diagrama gráfico para melhor entendimento do algoritmo <code>custom</code>:</li>
</ul>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/custom.png" alt="Diagrama Custom"></p>
<p>Primeiro, alocou-se ambos vetores que representam o <code>frame</code> e o <code>tempo_acesso</code> para cada frame ( <code>n</code> ). O vetor de frames inicia com todos os valores iguais a -1, indicando que nenhum frame está ocupado. O vetor de <code>tempo_acesso</code> inicia com todos os valores iguais a 0, indicando que nenhum frame foi acessado.</p>
<p>Em seguida, são requisitadas as páginas <code>0</code> , <code>1</code> , <code>2</code> , ..., <code>n-1</code> , que ocupam todos os frames disponíveis. A cada requisição, o tempo atual é incrementado e o tempo de acesso do frame correspondente é atualizado para o valor do tempo atual.</p>
<p>Após isso, a página <code>1</code> é requisitada novamente, o que atualiza o tempo de acesso do frame correspondente para o valor do tempo atual ( <code>n+1</code> ).</p>
<p>Depois da requisição da página <code>1</code> , as páginas <code>n</code> e <code>n+1</code> são requisitadas. Como não há frames disponíveis, o algoritmo <code>custom</code> seleciona o frame com o menor tempo de acesso, que é o frame da página <code>0</code> , e o substitui pela página <code>n</code> . E o frame que alocava a página <code>2</code> é substituído pela página <code>n+1</code> , pois o tempo de acesso do frame da página <code>2</code> é o menor dentre os disponíveis no momento.</p>
<p>Com isso, observamos que o algoritmo <code>custom</code> (LRU) remove sempre a página que está há mais tempo sem ser acessada, o que pode levar a uma taxa de faltas de página menor em cenários onde as páginas acessadas recentemente são necessárias novamente.</p>
<p>É perceptível que, neste caso, o algoritmo <code>custom</code> se sai melhor que o <code>rand</code> e o <code>fifo</code> , pois ele prioriza a remoção de páginas que não foram acessadas recentemente. Se fosse o caso de utilizar <code>fifo</code> , no tempo <code>n+3</code> , a página <code>1</code> seria removida, o que não é o ideal, pois ela foi acessada recentemente. Já o <code>rand</code> poderia remover qualquer página, sem considerar o histórico de acesso.</p>
<h3 id="5-resultados-e-an%C3%A1lises">5. Resultados e Análises</h3>
<p>A seguir, serão listados, para cada programa ( <code>alpha</code> , <code>beta</code> , <code>gamma</code> e <code>delta</code> ), uma sequência de gráficos que mostram os valores de <code>page faults</code> , <code>disk reads</code> e <code>disk writes</code> para cada algoritmo de substituição de página ( <code>rand</code> , <code>fifo</code> e <code>custom</code> ).</p>
<p>Para contextualizar os resultados, é importante entender o padrão de acesso à memória de cada programa de teste, conforme fornecido no projeto: Add commentMore actions</p>
<ul>
<li><strong>Alpha:</strong> Realiza acessos sequenciais em grandes blocos de memória.</li>
<li><strong>Beta:</strong> Ordena um grande vetor de dados, resultando em acessos complexos e não totalmente sequenciais.</li>
<li><strong>Gamma:</strong> Acessa de forma cíclica e repetida dois grandes vetores, caracterizando um padrão com forte localidade temporal em escala macro.</li>
<li><strong>Delta:</strong> Efetua um grande número de trocas de dados em posições aleatórias, simulando um cenário de pior caso sem localidade.</li>
</ul>
<p>A análise a seguir detalha o comportamento dos algoritmos de substituição de página (RAND, FIFO e CUSTOM) para cada programa de teste, com base nos dados de faltas de página, leituras de disco e escritas em disco.</p>
<p>Os seguintes testes foram da seguinte forma</p>
<pre class="hljs"><code><div>./virtmem &lt;list(range(3, 100))&gt; 100 &lt;[<span class="hljs-string">"rand"</span>, <span class="hljs-string">"fifo"</span>, <span class="hljs-string">"custom"</span>]&gt; &lt;[<span class="hljs-string">"alpha"</span>, <span class="hljs-string">"beta"</span>, <span class="hljs-string">"gamma"</span>, <span class="hljs-string">"delta"</span>]&gt;
</div></code></pre>
<blockquote>
<p>O trecho acima mistura Python e Bash, onde <code>list(range(3, 100))</code> gera uma lista de números de frames de 3 a 99, e os algoritmos e programas são iterados para cada combinação.</p>
</blockquote>
<p>Ou seja, para cada programa ( <code>alpha</code> , <code>beta</code> , <code>gamma</code> , <code>delta</code> ), foram testados os algoritmos de substituição de página ( <code>rand</code> , <code>fifo</code> e <code>custom</code> ) com um número de frames variando de 3 a 100 e fixamente com 100 páginas. Os resultados foram coletados e organizados em gráficos para análise.</p>
<blockquote>
<p>Cabe destacar que todos os testes de aleatoriedade foram executados com a semente de aleatoriedade <code>srand(0)</code> , para garantir a reprodutibilidade dos resultados.</p>
</blockquote>
<h4 id="51-resultados-dos-testes">5.1 Resultados dos testes</h4>
<h5 id="511-alpha">5.1.1 Alpha</h5>
<p>O programa <code>alpha</code> acessa a memória de forma sequencial em blocos. Essa característica leva a um comportamento distinto nos algoritmos de substituição.</p>
<ul>
<li><strong>Faltas de Página:</strong> Os algoritmos FIFO e CUSTOM apresentam um número de falhas de página que cai drasticamente para um valor constante e baixo quando o número de frames é suficiente para conter o <code>chunksize</code> do programa (aproximadamente 10 frames). Em contraste, o algoritmo RAND mostra uma redução gradual, mas consistentemente mais elevada de falhas em comparação com os outros dois após o ponto de inflexão.</li>
<li><strong>Leituras e Escritas de Disco:</strong> O padrão de leituras e escritas no disco segue o mesmo comportamento das faltas de página. Há uma queda acentuada para FIFO e CUSTOM, que se estabilizam em um patamar baixo, enquanto RAND decai de forma mais lenta.</li>
</ul>
<p>A performance idêntica entre FIFO e CUSTOM (LRU) sugere que o padrão de acesso sequencial do <code>alpha</code> não oferece oportunidades para o LRU explorar a localidade temporal. A página menos recentemente usada é sempre a primeira que entrou, tornando os dois algoritmos equivalentes nesse cenário. Add commentMore actions</p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/alpha/disk_reads_alpha.png" alt="disk_reads_alpha.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/alpha/disk_writes_alpha.png" alt="disk_writes_alpha.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/alpha/page_faults_alpha.png" alt="page_faults_alpha.png"></p>
<h5 id="512-beta">5.1.2 Beta</h5>
<p>O programa <code>beta</code> executa uma ordenação ( <code>qsort</code> ), resultando em um padrão de acesso à memória complexo e menos previsível.</p>
<ul>
<li><strong>Faltas de Página:</strong> Todos os algoritmos mostram uma tendência decrescente no número de falhas de página à medida que mais frames são disponibilizados. Os algoritmos FIFO e CUSTOM são novamente idênticos, apresentando um declínio em &quot;degraus&quot;, onde a performance se estabiliza por um intervalo de frames antes de cair novamente. RAND segue a tendência geral, mas de forma mais irregular. Add commentMore actions</li>
<li><strong>Leituras e Escritas de Disco:</strong> Os gráficos de leituras e escritas espelham o comportamento das faltas de página, com a mesma tendência decrescente em degraus para FIFO e CUSTOM.</li>
</ul>
<p>O padrão de &quot;escada&quot; indica que o desempenho melhora em saltos discretos, provavelmente quando o número de frames se torna suficiente para acomodar partições inteiras dos dados durante o processo de ordenação. A falta de vantagem do CUSTOM sobre o FIFO sugere que, embora o acesso não seja puramente sequencial, o padrão de referência às páginas é tão disperso que a localidade temporal não é explorada.</p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/beta/disk_reads_beta.png" alt="disk_reads_beta.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/beta/disk_writes_beta.png" alt="disk_writes_beta.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/beta/page_faults_beta.png" alt="page_faults_beta.png"></p>
<h5 id="513-gamma">5.1.3 Gamma</h5>
<p>O programa <code>gamma</code> computa o produto escalar entre dois grandes vetores repetidamente.</p>
<p><strong>Faltas de Página, Leituras e Escritas de Disco:</strong> Os gráficos mostram que os algoritmos FIFO e CUSTOM têm um desempenho idêntico e constante, independentemente do número de frames. Em contrapartida, o algoritmo RAND melhora de forma consistente à medida que mais frames são adicionados.</p>
<p>A performance constante de FIFO e CUSTOM é um exemplo clássico de &quot;thrashing&quot;. Adicionar mais frames não resolve o problema, pois o padrão de remoção sistemática continua. O algoritmo RAND, por sua natureza aleatória, consegue quebrar esse ciclo.</p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/gamma/disk_reads_gamma.png" alt="disk_reads_gamma.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/gamma/disk_writes_gamma.png" alt="disk_writes_gamma.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/gamma/page_faults_gamma.png" alt="page_faults_gamma.png"></p>
<h5 id="514-delta">5.1.4 Delta</h5>
<p>O programa <code>delta</code> realiza um grande número de trocas em locais aleatórios da memória, simulando um cenário de pior caso com baixa ou nenhuma localidade.</p>
<ul>
<li><strong>Faltas de Página, Leituras e Escritas de Disco:</strong> Nos três gráficos, todos os algoritmos (RAND, FIFO e CUSTOM) apresentam um desempenho quase idêntico. As curvas mostram uma queda quase perfeitamente linear à medida que o número de frames aumenta. A única pequena exceção é que o RAND tem um número de leituras de disco ligeiramente maior com poucos frames, mas converge rapidamente com os outros.</li>
</ul>
<p>Esse comportamento demonstra que, na ausência de localidade, o algoritmo de substituição de página se torna irrelevante. A probabilidade de acessar qualquer página é a mesma, então a escolha de qual página &quot;vítima&quot; remover (a mais antiga, a menos usada ou uma aleatória) não impacta o resultado final. A queda linear é esperada: com mais frames, a chance de uma página aleatoriamente acessada estar na memória aumenta proporcionalmente, reduzindo as faltas de página de forma linear.</p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/delta/disk_reads_delta.png" alt="disk_reads_delta.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/delta/disk_writes_delta.png" alt="disk_writes_delta.png"></p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/delta/page_faults_delta.png" alt="page_faults_delta.png"></p>
<h4 id="52-an%C3%A1lise-dos-resultados">5.2 Análise dos resultados</h4>
<p>A análise a seguir interpreta os gráficos obtidos para cada programa, destacando padrões, justificando semelhanças entre algoritmos e relacionando o comportamento observado com os conceitos de localidade e substituição de páginas.</p>
<h5 id="521-semelhan%C3%A7as-entre-fifo-e-custom">5.2.1 Semelhanças entre <code>fifo</code> e <code>custom</code></h5>
<p>Observa-se que, em muitos casos, os algoritmos <code>fifo</code> e <code>custom</code> apresentaram desempenho idêntico. Essa convergência ocorre principalmente quando:</p>
<ol>
<li>O padrão de acesso não reutiliza páginas antes de serem substituídas;</li>
<li>O número de frames disponíveis é insuficiente para manter páginas ativas em memória por tempo suficiente.</li>
</ol>
<p>Nessas situações, não há vantagem prática em considerar o histórico de acessos, pois a substituição ocorrerá de forma semelhante, pois tanto <code>fifo</code> quanto <code>custom</code></p>
<ul>
<li>Inserem a nova página no primeiro frame livre;</li>
<li>Quando os frames estão cheios, removem a “mais antiga”:
<ul>
<li><code>fifo</code> remove a página que entrou primeiro;</li>
<li><code>custom</code> remove a página que não foi acessada há mais tempo.</li>
</ul>
</li>
<li>Quando o padrão de acesso não reaproveita páginas antes de sua substituição, a lógica de remoção — seja pela ordem de chegada (FIFO) ou pela idade do último acesso (LRU) — leva à mesma escolha. Assim, os dois algoritmos convergem para um desempenho idêntico, como observado nos testes.</li>
</ul>
<p>Ou seja, os programas <code>alpha</code> , <code>beta</code> , <code>gamma</code> e <code>delta</code> não apresentam reutilização antes da substituição, não favorecem localidade temporal e, portanto, não se beneficiam de um algoritmo mais sofisticado como o <code>custom</code> .</p>
<p>Dessa forma, se nenhuma das páginas é reutilizada entre sua carga e sua substituição, ambas as estratégias convergem para o mesmo resultado.</p>
<h5 id="522-tend%C3%AAncia-geral-decrescente">5.2.2 Tendência Geral Decrescente</h5>
<p>Os gráficos de <code>disk reads</code> , <code>disk writes</code> e <code>page faults</code> seguem, em quase todos os casos, uma tendência decrescente à medida que o número de frames aumenta. Isso é esperado, pois:</p>
<ul>
<li>A tendência decrescente nos gráficos de page faults, disk reads e disk writes está diretamente relacionada à quantidade de frames disponíveis. Com mais frames, há maior capacidade de manter páginas na memória, reduzindo a necessidade de substituição e, consequentemente, os acessos ao disco.</li>
</ul>
<p>A queda não é sempre linear, dado que a distribuição de acessos e o comportamento dos programas variam, mas a tendência geral se mantém.</p>
<h5 id="523-comportamento-constante-do-gamma-com-fifo-e-custom">5.2.3 Comportamento constante do <code>gamma</code> com <code>fifo</code> e <code>custom</code></h5>
<p>O comportamento constante de faltas de página observado com <code>fifo</code> e <code>custom</code> no programa <code>gamma</code> indica substituições cíclicas. Ocorre que o programa <code>gamma</code> alterna entre dois vetores grandes de forma cíclica, que gera um comportamento constante de faltas de página, realizando operações de produto escalar em iterações completas típicas de cenários que levam ao fenômeno conhecido como thrashing. Embora o número de frames aumente, o padrão de acesso alternado entre dois grandes vetores força a substituição contínua de páginas que logo serão reutilizadas.</p>
<ol>
<li>Como os vetores são acessados de forma alternada, qualquer frame alocado para um vetor será substituído pouco depois por uma página do outro vetor.</li>
<li>Ambos os algoritmos operam de forma determinística nesse ciclo, o que impede ganho de desempenho mesmo com mais frames.</li>
</ol>
<p>Isso já não acontece com o <code>rand</code> porque o algoritmo escolhe aleatoriamente qual página remover da memória sempre que ocorre uma falta de página e não há frame livre. Dessa forma, o <code>rand</code> não apresenta um padrão constante, mas sim descendente, pois o número de frames aumenta e, consequentemente, o número de faltas de página diminui.</p>
<h5 id="524-comportamento-linear-de-delta">5.2.4 Comportamento linear de <code>delta</code></h5>
<p>Seja com qualquer algoritmo de substituição de página, o programa <code>delta</code> apresenta, num geral, um comportamento linear descendente (em <code>rand</code> é perceptível uma tendência) para leituras de disco, escritas de disco e faltas de página. Isso ocorre porque os acessos do programa são feitos de forma aleatória, sendo altamente dispersos e com baixíssima reutilização.</p>
<p>Dessa forma, à medida que o número de frames aumenta, mais páginas podem ser mantidas na memória - reduzindo a chance de substituições.</p>
<p>Ou seja, num geral, a tendência dos gráficos é de serem descendentes, mas pelo comportamento dos programas, acontece de não serem lineares. Porém, como o <code>delta</code> é extremamente disperso, ele apresenta o &quot;pior&quot; caso, que é o comportamento linear descendente.</p>
<h5 id="525-tempo-de-execu%C3%A7%C3%A3o">5.2.5 Tempo de execução</h5>
<p>Cabe destacar que o tempo de execução do programa <code>delta</code> é significativamente maior que o dos outros programas, devido à sua natureza de acessos aleatórios e dispersos. Isso resulta em um número elevado de faltas de página e, consequentemente, em mais leituras e escritas no disco.</p>
<p>Isso pode ser perceptível no seguinte gráfico que compara o tempo de execução dos programas:</p>
<p><img src="file:///home/ludvig/Documentos/vmem-simulator/relatorio/exec_time_avg_por_programa.png" alt="Tempo de Execução"></p>
<h2 id="ap%C3%AAndice">Apêndice</h2>
<h3 id="vazamento-de-mem%C3%B3ria">Vazamento de memória</h3>
<p>Durante toda a implementação do sistema, foram constantemente verificados os vazamentos de memória, utilizando o Valgrind, para garantir que não existam vazamentos no código final. A alocação dinâmica de memória é corretamente liberada com <code>delete[]</code> em seus respectivos destrutores ou métodos de limpeza. O objeto <code>Disk</code> é explicitamente deletado em <code>main.cpp</code> . A seguir, um exemplo de execução do Valgrind:</p>
<pre class="hljs"><code><div>valgrind ./virtmem 10 10 rand alpha --leak-check=full
</div></code></pre>
<p>Que obteve o seguinte retorno:</p>
<pre class="hljs"><code><div>==375405== Memcheck, a memory error detectorAdd commentMore actions
==375405== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==375405== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==375405== Command: ./virtmem 10 10 rand alpha --leak-check=full
==375405== 
use: virtmem &lt;npages&gt; &lt;nframes&gt; &lt;rand|fifo|custom&gt; &lt;alpha|beta|gamma|delta&gt;
==375405== 
==375405== HEAP SUMMARY:
==375405==     in use at exit: 0 bytes in 0 blocks
==375405==   total heap usage: 2 allocs, 2 frees, 74,752 bytes allocated
==375405== 
==375405== All heap blocks were freed -- no leaks are possible
==375405== 
==375405== For lists of detected and suppressed errors, rerun with: -s
==375405== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</div></code></pre>
<p>Ou seja, não foram encontrados vazamentos de memória durante a execução do sistema e todas as alocações de memória foram devidamente liberadas.</p>

</body>

</html>